package {{.PackageName}}

// GENERATED CODE, EDITS WILL BE LOST
//
// generated from {{.PackageName}}/{{.TypeName}}
// using http://github.com/brianstarke/go-beget/beget

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/jmoiron/sqlx"

	sq "github.com/lann/squirrel"
)

// {{.TypeName}}SearchRequest is a serializable SearchRequest for {{.TypeName}}.
type {{.TypeName}}SearchRequest struct {
	Fields []{{.TypeName}}Field `json:"fields"`
	Filters []{{.TypeName}}Filter `json:"filters"`
	OrderBy *{{.TypeName}}OrderBy `json:"orderBy"`
	Limit int `json:"limit"`
	Offset int `json:"offset"`
}

// {{.TypeName}}Filter is a filter specific to {{.TypeName}}
type {{.TypeName}}Filter struct {
	Field {{.TypeName}}Field `json:"field"`
	Value interface{} `json:"value"`
	Operator Operator `json:"operator"`
	Condition Condition `json:"condition"`
}

// {{.TypeName}}OrderBy is a sort directive that is specific to {{.TypeName}}
type {{.TypeName}}OrderBy struct {
	Field {{.TypeName}}Field `json:"field"`
	IsDescending bool `json:"isDescending"`
}

// AddFilter is a helper method to add a filter to a SearchRequest.  By default,
// the operator is EQ and the condition is AND.  If you want to override that:
//
//  var sr SearchRequest
//  sr.AddFilter("color", "red", func(f *{{.TypeName}}Filter){
//    f.Operator = GT
//    f.Condition = OR
//  })
//
// and you're all set.
func (sr *{{.TypeName}}SearchRequest) AddFilter(field {{.TypeName}}Field, value interface{}, cfg ...func(f *{{.TypeName}}Filter)) *{{.TypeName}}SearchRequest {
	f := {{.TypeName}}Filter{
		Field: field,
		Operator:  Eq,
		Condition: And,
		Value:     fmt.Sprint(value),
	}

	for _, c := range cfg {
		c(&f)
	}

	sr.Filters = append(sr.Filters, f)

	return sr
}

// AddFields adds fields to the select.  Helper method for chain building a
// {{.TypeName}}SearchRequest.
func (sr *{{.TypeName}}SearchRequest) AddFields(fields ...{{.TypeName}}Field) *{{.TypeName}}SearchRequest {
	sr.Fields = append(sr.Fields, fields...)

	return sr
}

// SetLimit sets the Limit.  Helper method for chain building a {{.TypeName}}SearchRequest
func (sr *{{.TypeName}}SearchRequest) SetLimit(limit int) *{{.TypeName}}SearchRequest {
	sr.Limit = limit

	return sr
}

// SetOffset sets the Offset.  Helper method for chain building a {{.TypeName}}SearchRequest
func (sr *{{.TypeName}}SearchRequest) SetOffset(offset int) *{{.TypeName}}SearchRequest {
	sr.Offset = offset

	return sr
}

// SetPage sets the Offset and Limit based on the page number and page size.
func (sr *{{.TypeName}}SearchRequest) SetPage(pageNumber, pageSize int) *{{.TypeName}}SearchRequest {
	return sr.
		SetOffset(pageNumber * pageSize).
		SetLimit(pageSize)
}

// SetOrderBy sets the Order By.  Helper method for chain building a SearchRequest
func (sr *{{.TypeName}}SearchRequest) SetOrderBy(field {{.TypeName}}Field, isDescending bool) *{{.TypeName}}SearchRequest {
	sr.OrderBy = &{{.TypeName}}OrderBy{
		Field:        field,
		IsDescending: isDescending,
	}

	return sr
}

// GenerateSelectSQL will generate an executable SQL statement and return the SQL
// string (with placeholders) and a slice of the values.
func (sr *{{.TypeName}}SearchRequest) GenerateSelectSQL() (string, []interface{}, error) {
	var s string

	if len(sr.Fields) == 0 {
		s = "*"
	} else {
		for _, f := range sr.Fields {
			s = s + f.DbFieldName() + ", "
		}
		s = strings.TrimRight(s, ", ")
	}

	psql := sq.StatementBuilder.
		PlaceholderFormat(sq.Dollar).
		Select(s).
		From("{{.TableName}}")

	sr.addPredicates(&psql)

	if sr.Limit > 0 {
		psql = psql.Limit(uint64(sr.Limit))
	}

	if sr.Offset > 0 {
		psql = psql.Offset(uint64(sr.Offset))
	}

	if sr.OrderBy != nil {
		var oBy string

		if sr.OrderBy.IsDescending {
			oBy = fmt.Sprintf("%s DESC", sr.OrderBy.Field.DbFieldName())
		} else {
			oBy = sr.OrderBy.Field.DbFieldName()
		}

		psql = psql.OrderBy(oBy)
	}

	return psql.ToSql()
}

// GenerateCountSQL will generate an executable SQL statement and return the SQL
// string (with placeholders) and a slice of the values.
func (sr *{{.TypeName}}SearchRequest) GenerateCountSQL() (string, []interface{}, error) {
	psql := sq.StatementBuilder.
		PlaceholderFormat(sq.Dollar).
		Select("COUNT(*) AS cnt").
		From("{{.TableName}}")

	sr.addPredicates(&psql)

	return psql.ToSql()
}

func (sr *{{.TypeName}}SearchRequest) addPredicates(psql *sq.SelectBuilder) {
	var ands sq.And
	var ors sq.Or

	for _, f := range sr.Filters {
		e := sq.Expr(sr.buildExpr(f), f.Value)

		if f.Operator == IsNull || f.Operator == NotNull {
			e = sq.Expr(sr.buildExpr(f))
		}

		if f.Condition == Or {
			ors = append(ors, e)
		} else {
			ands = append(ands, e)
		}
	}

	if len(ors) > 0 {
		*psql = psql.Where(ors)
	}

	if len(ands) > 0 {
		*psql = psql.Where(ands)
	}
}

func (sr {{.TypeName}}SearchRequest) buildExpr(f {{.TypeName}}Filter) string {
	var operator string

	switch f.Operator {
	case Eq:
		operator = "="
	case NotEq:
		operator = "!="
	case Like:
		return fmt.Sprintf("cast (%s as varchar(64)) ILIKE ?", f.Field)
	case NotLike:
		return fmt.Sprintf("cast (%s as varchar(64)) NOT ILIKE ?", f.Field)
	case GreaterThan:
		operator = ">"
	case GreaterThanOrEq:
		operator = ">="
	case LesserThan:
		operator = "<"
	case LesserThanOrEq:
		operator = "<="
	case IsNull:
		return fmt.Sprintf("%s IS NULL", f.Field)
	case NotNull:
		return fmt.Sprintf("%s IS NOT NULL", f.Field)
	default:
		operator = "="
	}

	return fmt.Sprintf("%s %s ?", f.Field.DbFieldName(), operator)
}

// ExecuteSearch will take a sql.DB connection and execute this search request
func (sr *{{.TypeName}}SearchRequest) ExecuteSearch(db *sql.DB, results *[]{{.TypeName}}) error {
	// Generate the SQL
	sqlStr, values, err := sr.GenerateSelectSQL()

	if err != nil {
		return err
	}

	// Upgrade to sqlx connection
	dbx := sqlx.NewDb(db, "postgres")

	return dbx.Select(results, sqlStr, values...)
}

// ExecuteCount will take a sql.DB connection and execute a SELECT COUNT
func (sr *{{.TypeName}}SearchRequest) ExecuteCount(db *sql.DB) (int32, error) {
	// Generate the SQL
	sqlStr, values, err := sr.GenerateCountSQL()

	if err != nil {
		return 0, err
	}

	// Upgrade to sqlx connection
	dbx := sqlx.NewDb(db, "postgres")

	var results []struct {
		Count int32 `db:"cnt"`
	}

	err = dbx.Select(&results, sqlStr, values...)

	if err != nil {
		return 0, err
	}

	return results[0].Count, nil
}

// New{{.TypeName}}SearchHandlerFunc returns an HTTP handler func for
// {{.TypeName}}SearchRequests. It returns 200 and the results
// on success, 404 if not a POST, 400 on bad JSON, 500 on any
// other error.
func New{{.TypeName}}SearchHandlerFunc(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != "POST" {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		b, err := ioutil.ReadAll(r.Body)

		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprint(w, "No search request in the request body")
			return
		}

		var sr {{.TypeName}}SearchRequest
		err = json.Unmarshal(b, &sr)

		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintf(w, "Error deserializing search request: %s", err.Error())
			return
		}

		var results []{{.TypeName}}
		err = sr.ExecuteSearch(db, &results)

		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "Error executing search request: %s", err.Error())
			return
		}

		jsonResults, err := json.Marshal(results)

		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "Error serializing search results: %s", err.Error())
			return
		}

		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, string(jsonResults))

		return
	}
}
